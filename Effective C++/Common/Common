

//자료형
===================================================================================================================
자료형
- 크기 단위(byte)

- 다양한 범위의 자료형 '안전을 보증'하며 프로그램을 실행하지 않고도 결정할 수 있는 프로그램의 특성

- 같은 비트여도 자료형의 표현에 따라 컴퓨터는 다른 숫자로 인식함
   ex) unsigned char c = 255
       char c1 = 255
	   c와 c1은 1111 1111 로 서로 같은 비트값을 가지지만,
	   컴퓨터는 c에 저장된 값을 255로 c1에 저장된 값은 -1(1이랑 더했을 때 0이 되는 값)로 인식함 


자료형의 종류
- 정수형 데이터 표현 방식과 실수형 데이터 표현 방식은 다르기 때문에 구분함

- 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하는 것이 좋음
   ex) int a = 10 + static_cast<int>(10.1234f);

- 정수형
   - char(1byte, 8bit)		 => 2^8가지의 숫자 표현 가능(-2^7 ~ 2^7-1)

   - short(2btye, 16bit)	 => 2^16가지의 숫자 표현 가능(-2^15 ~ 2^15-1)

   - int(4byte, 32bit)		 => 2^32가지의 숫자 표현 가능(-2^32 ~ 2^32-1)

   - long(4byte, 32bit)		 => 2^32가지의 숫자 표현 가능(-2^32 ~ 2^32-1)

   - long long(8byte, 64bit) => 2^64가지의 숫자 표현 가능(-2^64 ~ 2^64-1)

- 실수형(부동소수점 표현 방식)
   - float(4byte, 32bit)	 => 2^32가지의 숫자 표현 가능

   - double(8byte, 64bit)	 => 2^64가지의 숫자 표현 가능

   - 실수 표현방식은 정밀도에 의존
      - 따라서 double 자료형이 float보다 더 많은 메모리를 사용하므로 더 많은 아래의 소수점까지 정확하게 표현이 가능

   - 실수의 맨 마지막에 f를 붙여주면 그 실수는 float 데이터 타입으로 인식
      ex) 4.f(float) 4.0(double)


양수(0 포함)만 취급하는 자료형
- 자료형 앞에 'unsigned'를 붙여주면 양수(0 포함)만 취급하는 자료형이 됨

- 저장할 수 있는 숫자의 범위가 0부터 시작함

- 최대로 저장할 수 있는 숫자보다 큰 숫자를 넣는 경우 unsigned 자료형의 변수에 저장된 값은 0이 됨(최대로 저장할 수 있는 비트가 넘어가기 때문)


보수
- 두 수의 합이 진법의 밑수가 되게 하는 수
   ex) 10진수 4의 10의 보수는 6

- 컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기만 이용하기 때문에 뺄셈을 변환하여 계산
   ex) 3 - 1 => 3 + (-1) 로 변환하여 계산

- 1의 보수 구하는 법
   - 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 1의 보수를 얻을 수 있음
   - 또는 각 자릿수의 비트값을 모두 반전시키면 됨(0 -> 1, 1 -> 0)
      ex) 0000 0100(2)의 1의 보수는
	      
		  1111 1111(2)
	    - 0000 0100(2)
		= 1111 1011(2) : 0000 0100(2)의 1의 보수
    
- 2의 보수 구하는 법(음의 정수 찾기)
   - 1의 보수에 1을 더한 값
       ex) 1111 1011(2) : 0000 0100(2)의 1의 보수

	      1111 1011(2)
	    + 0000 0001(2)
		= 1111 1100(2) : 0000 0100(2)의 2의 보수

	  [확인]
	      0000 0100(2)
	    + 1111 1100(2)
		= 0000 0000(2) = 0
===================================================================================================================


//연산자
===================================================================================================================
대입 연산자
- '='


산술 연산자
- '+, -, *, /, %(모듈러스, 실수끼리 혹은 실수가 포함되는 연산에는 수행 불가. 나머지를 측정할 수 없음)'

- '++, --'
   - 변수 앞에 붙으면 전위연산자(증가시키고 값을 사용), 뒤에 붙으면 후위연산자(값을 사용하고 증가)
      ex) int data = 0, a = 10; 
	      data = ++a(전위) => 자기 자신을 먼저 증가하고 다음 연산을 진행(객체로 반환)
		                   => 진행단계에서는 data에 저장된 값은 a가 1증가한 11이 저장됨
						   => a의 값도 11로 증가

		  data = a++(후위) => 모든 연산이 끝나고 마지막에 증가(연산 결과값(상수(const))을 반환)
		                   => 진행단계에서는 data에 저장된 값은 10이 저장되고 다음 줄로 넘어갈 때 1이 증가
						   => a의 값도 11로 증가
						   
   - 일반적으로 전위연산자가 후위연산자보다 속도가 빠름
      - 후위연산이 이루어지기 전의 값을 저장하기 위한 임시객체(변수)를 만들어 메모리를 사용하기 때문
	  - 임시객체(변수)에 값을 저장할 때 복사생성자나 연산자 오버로딩(=) 함수가 호출될 수 있기 때문

- 보통은 대입 연산자보다 산술 연산자의 우선순위가 높음


논리 연산자
- '!(reverse), &&(and), ||(or)'

- 0이 아닌 모든 값은 참임(주로 1)

- true(=1), false(=0)


비교 연산자
- '==(같은지), !=(다른지), <, >, <=, >='

- 논리 연산자보다 비교 연산자가 우선순위가 높음


비트 연산자
- 쉬프트'<<(비트를 오른쪽으로 밈), >>(비트를 왼쪽으로 밈)'
   ex) unsigned char byte = 1;  
       byte = byte << 1; =>  byte <<= 1 => 오른쪽으로 한 칸 밈 byte = 2(2^1)가 됨
	   byte = byte << 3; =>  byte <<= 3 => 오른쪽으로 세 칸 밈 byte = 8(2^3)이 됨

	   unsigned char byte = 13;  
	   byte = byte >> 1; =>  byte >>= 1 => 왼쪽으로 한 칸 밈 byte = (13 / 2^1 = 6)가 됨

- '&(비트 곱), |(비트 합), ^(xor, 같으면 0 다르면 1), ~(반전)'
   - 비트의 자릿수 단위로 각각 연산

   - &(비트 곱)
      - 둘다 1인 경우 1, 하나라도 다르면 0

   - |(비트 합)
      - 둘 중 하나라도 1이면 1 둘 다 0이면 0

   - ^(xor)
      - 두 개가 같으면 0 다르면 1

   - ~(반전)
      - 1은 0으로 0은 1로 반전

- 비트는 게임 프로그래밍에서 상태를 저장할 때 사용
   - 각 자릿수에 1값을 넣어 표현
      ex) 목마름 1, 배고픔 2, 기분 좋음 4
	      unsigned char iStatus = 0;
		  
		  [상태 추가]
		  iStatus |= 목마름;		 =>0000 0001
		  iStatus |= 배고픔;		 =>0000 0011
		  iStatus |= 기분 좋음;   =>0000 0111

		  iStatus => 0000 0111

          [상태값 체크]
		  if(iStatus & 목마름) => 비트 자릿수 값을 비교해서 둘 다 1이면 true 아니면 false 반환

		  [상태 제거]
		  iStatus &= ~목마름;  
		     0000 0111 => iStatus
		   & 1111 1110 => ~목마름
		     0000 0110 => 목마름이 빠진 상태
===================================================================================================================


//변수
===================================================================================================================
지역변수
- '{}'안에 선언된 변수


전역변수



정적변수



외부변수


변수명 규칙
- 변수의 이름이 같은 경우 '{}'안에 선언된 같은 영역의 지역변수가 우선순위가 높음
   ex) int iName = 0;

       {
	      int iName = 100;

		  iName; => 같은 영역의 지역변수를 사용, 100
	   }

	   iName; => 같은 영역의 지역변수를 사용, 0
	   
===================================================================================================================


//함수
===================================================================================================================
모듈화
- 하나의 기능을 명확하게 구분하고 쪼개는 작업

===================================================================================================================


//제어문
===================================================================================================================
조건문
- if, else, else if

- switch(case)

- 삼항 연산자(조건? true: false)


반복문
- for
   - for( /*반복자 초기화*/ ; /*반복자 조건 체크*/ ; /*반복자 변경*/ )

   - 반복자의 조건이 참인 경우에만 반복문 내부를 수행
      ex) for(int i = 0; i < 10; ++i) => 반복문 내부를 10번 수행(i의 값이 10보다 작을 때까지)
	      {

	      }

- while
   - while( /*조건 체크*/ )


분기문
- 프로그램의 순차적 수행 순서에 따르지 않고 다른 명령을 수행하도록 이행 시키는 명령어

- continue
   - 현재 수행 중인 루프(반복문)의 처음으로 되돌아가는 명령어
   - 루프를 벗어나는 것이 아님(break와 다름)
   - 해당 분기문 다음에 있는 내용들을 무시(수행하지 않고)하고 루프의 처음으로 돌아감

- break
   - 현재 수행 중인 루프(반복문) 중 가장 가까운 루프를 벗어나는 명령어

- return
   - 자신(함수)를 호출한 곳으로 다시 되돌아가는 명령어
   - 자신(함수)를 호출한 곳으로 돌아가면서 '상수' 또는 '변수'의 값을 반환
   - main 함수의 return은 프로그램의 종료를 의미

===================================================================================================================