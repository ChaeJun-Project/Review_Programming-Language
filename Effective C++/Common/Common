
//실행파일 생성 단계 및 실행파일 실행 과정
===================================================================================================================
실행파일의 생성 단계
1)프로그램 작성
   - 고급언어(C,C++,C# 등)으로 프로그램 작성
   - (.c) 파일

2)전처리기
   - #include, #define과 같이 #으로 시작하는 지시자의 지시에 따라 소스코드를 적절히 변경(여전히 프로그래밍 언어임)
   - (.c) 파일을 (.i) 파일로 변경

3)컴파일러
   - 어셈블리 언어: 기계가 이해하는 것을 기호 형태로 나타낸 언어
   - 소스 코드를 어셈블리 코드로 번역
   - C프로그램을 어셈블리 언어 프로그램(.s)으로 변경

4)어셈블러
   - 어셈블리 코드를 컴퓨터(CPU)가 이해할 수 있는 바이너리 코드(1과0으로 이루어진 기계어)로 번역
   - 어셈블리 언어 프로그램(.s)을 오브젝트 파일(.obj)로 변경

5)링커
   - 오브젝트 파일들과 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는 작업
   - 실행파일(.exe) 생성. 실행파일에는 컴퓨터에게 일을 시키기위한 명령어(바이너리 코드)가 들어있음


실행파일의 실행 과정
1)로더
   - 실행 프로그램을 메인 메모리에 적재해서 실행할 수 있게 해줌

2)Fetch
   - 메모리상에 존재하는 명령어를 CPU로 가져옴

3)Decode
   - 명령어를 CPU가 해석

4)Execution
   - 해석된 명령어의 명령대로 CPU가 실행(CPU의 ALU에 의해 연산)
===================================================================================================================

//라이브러리
===================================================================================================================
라이브러리
- 다른 프로그램들과 링크되기 위하여 존재하는 하나 이상의 서브루틴이나 함수들의 집합


라이브러리 사용이유
- 코드의 재사용

- 코드의 부품화 실현

- 소스를 제공하지 않아 기술 유출 방지(But 제공하는 경우도 있음)

- 사용자의 개발시간 단축
===================================================================================================================

//자료형
===================================================================================================================
자료형
- 크기 단위(byte)

- 다양한 범위의 자료형 '안전을 보증'하며 프로그램을 실행하지 않고도 결정할 수 있는 프로그램의 특성

- 같은 비트여도 자료형의 표현에 따라 컴퓨터는 다른 숫자로 인식함
   ex) unsigned char c = 255
       char c1 = 255
	   c와 c1은 1111 1111 로 서로 같은 비트값을 가지지만,
	   컴퓨터는 c에 저장된 값을 255로 c1에 저장된 값은 -1(1이랑 더했을 때 0이 되는 값)로 인식함 


자료형의 종류
- 정수형
   - char(1byte, 8bit)		 => 2^8가지의 숫자 표현 가능(-2^7 ~ 2^7-1)

   - short(2btye, 16bit)	 => 2^16가지의 숫자 표현 가능(-2^15 ~ 2^15-1)

   - int(4byte, 32bit)		 => 2^32가지의 숫자 표현 가능(-2^32 ~ 2^32-1)

   - long(4byte, 32bit)		 => 2^32가지의 숫자 표현 가능(-2^32 ~ 2^32-1)

   - long long(8byte, 64bit) => 2^64가지의 숫자 표현 가능(-2^64 ~ 2^64-1)

- 실수형
   - float(4byte, 32bit)	 => 2^32가지의 숫자 표현 가능

   - double(8byte, 64bit)	 => 2^64가지의 숫자 표현 가능


양수(0 포함)만 취급하는 자료형
- 자료형 앞에 'unsigned'를 붙여주면 양수(0 포함)만 취급하는 자료형이 됨

- 저장할 수 있는 숫자의 범위가 0부터 시작함

- 최대로 저장할 수 있는 숫자보다 큰 숫자를 넣는 경우 unsigned 자료형의 변수에 저장된 값은 0이 됨(최대로 저장할 수 있는 비트가 넘어가기 때문)


보수
- 두 수의 합이 진법의 밑수가 되게 하는 수
   ex) 10진수 4의 10의 보수는 6

- 컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기만 이용하기 때문에 뺄셈을 변환하여 계산
   ex) 3 - 1 => 3 + (-1) 로 변환하여 계산

- 1의 보수 구하는 법
   - 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 1의 보수를 얻을 수 있음
   - 또는 각 자릿수의 비트값을 모두 반전시키면 됨(0 -> 1, 1 -> 0)
      ex) 0000 0100(2)의 1의 보수는
	      
		  1111 1111(2)
	    - 0000 0100(2)
		= 1111 1011(2) : 0000 0100(2)의 1의 보수
    
- 2의 보수 구하는 법
   - 1의 보수에 1을 더한 값
       ex) 1111 1011(2) : 0000 0100(2)의 1의 보수

	      1111 1011(2)
	    + 0000 0001(2)
		= 1111 1100(2) : 0000 0100(2)의 2의 보수

	  [확인]
	      0000 0100(2)
	    + 1111 1100(2)
		= 0000 0000(2) = 0
===================================================================================================================
