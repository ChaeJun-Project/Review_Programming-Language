
//실행파일 생성 단계 및 실행파일 실행 과정
===================================================================================================================
실행파일의 생성 단계
1)프로그램 작성
   - 고급언어(C,C++,C# 등)으로 프로그램 작성
   - (.c) 파일

2)전처리기
   - #include, #define과 같이 #으로 시작하는 지시자의 지시에 따라 소스코드를 적절히 변경(여전히 프로그래밍 언어임)
   - (.c) 파일을 (.i) 파일로 변경

3)컴파일러
   - 어셈블리 언어: 기계가 이해하는 것을 기호 형태로 나타낸 언어
   - 소스 코드를 어셈블리 코드로 번역
   - C프로그램을 어셈블리 언어 프로그램(.s)으로 변경

4)어셈블러
   - 어셈블리 코드를 컴퓨터(CPU)가 이해할 수 있는 바이너리 코드(1과0으로 이루어진 기계어)로 번역
   - 어셈블리 언어 프로그램(.s)을 오브젝트 파일(.obj)로 변경

5)링커
   - 오브젝트 파일들과 프로그램 내에서 참조하는 함수나 라이브러리들을 하나로 묶는 작업
   - 실행파일(.exe) 생성. 실행파일에는 컴퓨터에게 일을 시키기위한 명령어(바이너리 코드)가 들어있음


실행파일의 실행 과정
1)로더
   - 실행 프로그램을 메인 메모리에 적재해서 실행할 수 있게 해줌

2)Fetch
   - 메모리상에 존재하는 명령어를 CPU로 가져옴

3)Decode
   - 명령어를 CPU가 해석

4)Execution
   - 해석된 명령어의 명령대로 CPU가 실행(CPU의 ALU에 의해 연산)
===================================================================================================================

//라이브러리
===================================================================================================================
라이브러리
- 다른 프로그램들과 링크되기 위하여 존재하는 하나 이상의 서브루틴이나 함수들의 집합


라이브러리 사용이유
- 코드의 재사용

- 코드의 부품화 실현

- 소스를 제공하지 않아 기술 유출 방지(But 제공하는 경우도 있음)

- 사용자의 개발시간 단축
===================================================================================================================

//자료형
===================================================================================================================
자료형
- 크기 단위(byte)

- 다양한 범위의 자료형 '안전을 보증'하며 프로그램을 실행하지 않고도 결정할 수 있는 프로그램의 특성

- 같은 비트여도 자료형의 표현에 따라 컴퓨터는 다른 숫자로 인식함
   ex) unsigned char c = 255
       char c1 = 255
	   c와 c1은 1111 1111 로 서로 같은 비트값을 가지지만,
	   컴퓨터는 c에 저장된 값을 255로 c1에 저장된 값은 -1(1이랑 더했을 때 0이 되는 값)로 인식함 


자료형의 종류
- 정수형 데이터 표현 방식과 실수형 데이터 표현 방식은 다르기 때문에 구분함

- 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현방식의 피 연산자가 연산될 경우 명시적으로 변환하는 것이 좋음
   ex) int a = 10 + static_cast<int>(10.1234f);

- 정수형
   - char(1byte, 8bit)		 => 2^8가지의 숫자 표현 가능(-2^7 ~ 2^7-1)

   - short(2btye, 16bit)	 => 2^16가지의 숫자 표현 가능(-2^15 ~ 2^15-1)

   - int(4byte, 32bit)		 => 2^32가지의 숫자 표현 가능(-2^32 ~ 2^32-1)

   - long(4byte, 32bit)		 => 2^32가지의 숫자 표현 가능(-2^32 ~ 2^32-1)

   - long long(8byte, 64bit) => 2^64가지의 숫자 표현 가능(-2^64 ~ 2^64-1)

- 실수형(부동소수점 표현 방식)
   - float(4byte, 32bit)	 => 2^32가지의 숫자 표현 가능

   - double(8byte, 64bit)	 => 2^64가지의 숫자 표현 가능

   - 실수 표현방식은 정밀도에 의존
      - 따라서 double 자료형이 float보다 더 많은 메모리를 사용하므로 더 많은 아래의 소수점까지 정확하게 표현이 가능

   - 실수의 맨 마지막에 f를 붙여주면 그 실수는 float 데이터 타입으로 인식
      ex) 4.f(float) 4.0(double)


양수(0 포함)만 취급하는 자료형
- 자료형 앞에 'unsigned'를 붙여주면 양수(0 포함)만 취급하는 자료형이 됨

- 저장할 수 있는 숫자의 범위가 0부터 시작함

- 최대로 저장할 수 있는 숫자보다 큰 숫자를 넣는 경우 unsigned 자료형의 변수에 저장된 값은 0이 됨(최대로 저장할 수 있는 비트가 넘어가기 때문)


보수
- 두 수의 합이 진법의 밑수가 되게 하는 수
   ex) 10진수 4의 10의 보수는 6

- 컴퓨터 내부에서는 사칙연산을 할 때 덧셈을 담당하는 가산기만 이용하기 때문에 뺄셈을 변환하여 계산
   ex) 3 - 1 => 3 + (-1) 로 변환하여 계산

- 1의 보수 구하는 법
   - 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 1의 보수를 얻을 수 있음
   - 또는 각 자릿수의 비트값을 모두 반전시키면 됨(0 -> 1, 1 -> 0)
      ex) 0000 0100(2)의 1의 보수는
	      
		  1111 1111(2)
	    - 0000 0100(2)
		= 1111 1011(2) : 0000 0100(2)의 1의 보수
    
- 2의 보수 구하는 법(음의 정수 찾기)
   - 1의 보수에 1을 더한 값
       ex) 1111 1011(2) : 0000 0100(2)의 1의 보수

	      1111 1011(2)
	    + 0000 0001(2)
		= 1111 1100(2) : 0000 0100(2)의 2의 보수

	  [확인]
	      0000 0100(2)
	    + 1111 1100(2)
		= 0000 0000(2) = 0
===================================================================================================================

//연산자
===================================================================================================================
대입 연산자
- '='

산술 연산자
- '+, -, *, /, %(모듈러스, 실수끼리 혹은 실수가 포함되는 연산에는 수행 불가. 나머지를 측정할 수 없음)'

- '++, --'
   - 변수 앞에 붙으면 전위연산자, 뒤에 붙으면 후위연산자
      ex) int data = 0, a = 10; 
	      data = ++a(전위) => 먼저 증가하고 다음 연산을 진행
		                   => 진행단계에서는 data에 저장된 값은 a가 1증가한 11이 저장됨
						   => a의 값도 11로 증가

		  data = a++(후위) => 모든 연산이 끝나고 마지막에 증가(우선순위가 가장 마지막으로 밀림)
		                   => 진행단계에서는 data에 저장된 값은 10이 저장되고 다음 줄로 넘어갈 때 1이 증가
						   => a의 값도 11로 증가
						   
   - 일반적으로 전위연산자가 후위연산자보다 속도가 빠름
      - 후위연산이 이루어지기 전의 값을 저장하기 위한 임시변수를 만들어 메모리를 사용하기 때문

- 보통은 대입 연산자보다 산술 연산자의 우선순위가 높음


논리 연산자
- '!(reverse), &&(and), ||(or)'

- 0이 아닌 모든 값은 참임(주로 1)

- true(=1), false(=0)
===================================================================================================================

